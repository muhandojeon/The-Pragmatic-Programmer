# 실용주의 접근법

## ETC, 좋은 설계는 나쁜 설계보다 바꾸기 쉽다.

바꾸기 더 쉽게, Easier to Change 원칙을 따르자.

내가 방금 한 일이 전체 시스템을 바꾸기 쉽게 만들었을까, 어렵게 만들었을까?를 자주 되물어보자.

## DRY

모든 지식은 시스템 내에서 단 한 번만, 애매하지 않고, 권위 있게 표현되어야 한다.

DRY가 실용주의 프로그래머의 도구 상자 중 가장 중요한 도구 중 하나이다.

DRY에 위반한 예로, 네이밍을 잘해둔 함수에 주석을 다는 경우가 있다.

계산하여 나타낼 수 있음에도 불필요하게 새로운 변수를 만드는 것 또한 DRY에 위반된다.

```typescript
export function Component() {
  const [firstName, setFirstName] = useState('');
  const [lastName, setLastName] = useState('');

  // Bad
  const [fullName, setFullName] = useState('');

  useEffect(() => {
    ...
  }, [...])

  // Good
  const fullName = firstName + lastName;
}
```

모듈의 자료 구조에 접근할 때는 가능한 접근자(accessor)를 이용하자.

> 자료구조의 네이밍을 변경하는 등 내부에서 구현을 수정하더라도, 외부는 수정될 필요가 없게 된다.

> 가져올 때 로그 등 추가 로직을 더할 수 있다.

## 직교성

하나가 바뀌어도 나머지에 어떤 영향도 주지 않으면 서로 직교한다고 할 수 있다.

문서화에도 직교성은 적용된다. 내용과 표현이라는 축이 직교성을 가진다. 내용은 텍스트이고 표현은 디자인이라고 생각하자. 내용이 변하는 것과 디자인이 변경되는 것은 거의 무관하다.

> 저는 연습문제 1번의 해답이 왜 Split2인지 모르겠습니다...

## 가역성

가역성은 반응 시 초기 상황으로 되돌아올 수 있는지에 대한 여부를 말한다.

되돌릴 수 없는 결정을 줄여야 하는 까닭은, 프로젝트 초기에 최선의 결정을 내리지 못할 확률이 높기 떄문이다.

그래서 유연하게 작성해야 하며 생각 또한 유연해야 한다.

> 최대한 프로젝트 초기에는 기술을 덜 얹는 것이 좋지 않나 싶다. 명확하지 않다면 Jotai, Zustand 대신 Context API를 우선 선택해보는 등...

> 한 번 정한 스택이니 이대로 쭉 가자, 바꾸기엔 늦었다라는 마인드를 버리자.

## 예광탄

시스템을 정의하는 가장 중요한 요구 사항을 찾아라. 혹은 가장 위험이 커 보이는 곳을 찾고 이에 대한 우선순위를 높여라.

> MVP부터 빨리 개발해보아라, 위험한 것은 최대한 빨리 확인해보아라라는 의미로 해석된다.

작동하는 것을 사용자가 일찍 보게 만들 수 있다. 그리고 팀원, 혹은 고위층 인사들에게 보여줄 것이 생긴다.

## 프로토타입

프로토타입은 예광탄과 달리, 한 번 쓰이고 버려질 코드이다.

버려질 것이고 가설을 빠르게 확인하기 위한 것으로, 추상화 수준이 높은 언어로 빠르게 확인해보아도 된다.

혹은 꼭 재료가 코드일 필요는 없다. 그림판, 화이트보드여도 된다.

## 도메인 언어

> 허허..! 이해를 거의 못했습니다.

## 추정

추정치에 대해 항상 좋은 답을 얻을 수 있는 방법은 이미 그 일을 해본 사람에게 물어보는 것이다.

코드와 함께 프로젝트 일정도 반복하며 조정하라.

> 이 스킬에 대해서 필요성을 많이 느낀 적이 있다. 이 일을 해보지 않은 사람에겐 쉬워보이고, 어렵다는 것을 납득시키기 위해서는 에너지가 소모되었기 때문이다.

> 여기서는 구체적인 예시가 적어서인지, 일을 완수하는 데에 얼마나 걸릴지 추정하는 방법에 대해 기대해서인지 잘 와닿지 않는다.