# 2장. 실용주의 접근법
## Topic8 좋은 설계의 핵심
좋은 설계는 나쁜 설계보다 바꾸기 쉽다. 
 왜 결합도를 줄이면 좋을까? => 관심사를 분리함으로써 더 바꾸기 쉬워지니까.
 왜 단일 책임 원칙이 유용하냐? => 요구사항이 바뀌더라도 모듈 하나만 바꾸면 되니까
 왜 이름 짓기가 중요한가? 이름이 좋으면 코드가 읽기 쉬워지고 코드를 바꾸려면 코드를 읽어야 하니까
 ETC!(easier to change!) 바꾸기 쉽게!

## Topic9 DRY: 중복의 해악

여기서의 중복은 물리적인 의미의 중복이 아니라, 의미론적인 중복이라고 생각한다.
겉모양이 완전히 동일한 코드를 중복으로 인지하고 기계적으로 합치다가 서로 무관해야하는 모듈간의 결합도가 높아져서 떼어놓기 위해 고생하는 경우가 종종 있음.
모든 코드 중복이 지식의 중복은 아니다.

## Topic10 직교성
직교성이란?
- 직교한다 → 두개의 선은 독립적
- 컴퓨터 과학에선 독립성, 디커플링을 의미
- 비-직교적인 시스템: 모든 행동에 따라 다른 사이드 이펙트가 발생

직교성의 장점
- tip17. 관련 없는 것들 간에 서로 영향이 없도록 하라
- 우리가 설계하고 싶은것은 독립적인 컴포넌트
- 직교적인 시스템은 생상선 향상과 리스크 감소가 있다

설계
- 특정 기능에 대한 요구 사항을 대폭 변경하는 경우 몇 개의 모듈이 영향을 받는가?
  - 직교적인 시스템은 답이 하나
- 현실 세계의 변화와 설계 사이의 결합도를 얼마나 줄였는지도 확인 (전화번호, 주민 등록 번호 등)
  - 자신의 힘으로 제어할 수 없는 속성에 의존하지 말라

> **그리고 여러분이 헬리콥터 조종사라면 생선을 먹지 말라...**(뭔소리지)

## Topic11 가역성
> 당신이 가진 생각이 딱 하나밖에 없다면, 그것만큼 위험한 것이 없다
=> 세상에서 가장 무서운 사람은 책을 딱 한 권만 읽은 사람이다.

- 가역성 : 초기(이전) 상태로 돌아가기 쉬운가?
- 무언가를 하는데 여러가지 길이 있다. (이 방법으로만 해결해야한다 X)
- 중요한 결정은 쉽게 되돌릴 수 없다 (DB, 아키텍처, 배포 모델 등)
- tip18. 최종 결정이란 없다
  - 결정은 계속 바뀐다 생각해라
- 유연한 아키텍처
  - 새로운, 대유행하는 기술을 계속해서 추가하고 경외하는 환경에서 무언가 작동했다는 것이 기적
  - tip19. 유행을 좇지 말라
    - 누구도 어떤 미래가 다가올지 알 수 없다
    - 우리가 할 수 있는 것은 바꾸기 쉽게 만든는 것

간혹 먼 미래를 바라보고 코딩하는 것이 안좋은 결과를 낳는 경우가 종종 있다.
그럴때 과연 미래를 대비하는 코드를 미리 작성하는 것이 옳은 결정일까?


## Topic12 예광탄
- 예광탄: 궤적을 그려주는 탄 → 이를 기반으로 영점 조준
  - 요구 사항으로부터 최종 시스템의 일부 측면까지 빨리, 눈에 보이게, 반복적으로 도달하게 해 줄 무언가가 있어야 한다
  - 요구 사항에서 의문이 드는 부분이나 가장 위험이 커 보이는 곳의 코드를 가장 먼저 작성하기 
- tip20. 목표물을 찾기 위해 예광탄을 써라
  - 실용주의는 세세한 명세 파악 보단 소프트웨어 판 예광탄을 선호
  - 일반 탄환과 동일한 환경 및 제약 조건에서 발사되기 때문
  - 실제 환경과 동일한 테스트 환경, 카나리 배포 등
- 예광탄 코드는 한번 쓰고 버리려고 만드는 것이 아님
  - 예광탄 코드는 영점 조절이 핵심
  - 오류 검사, 올바른 구조, 문서화, 자체 검사 를 갖추어야 함
- 예광탄 코드의 장점
  - 사용자 및 후원자, 고위 인사 등이 뭔가 작동하는 것을 일찍 보게 됨
  - 개발자가 들어가서 일할 수 있는 구조 획득
  - 통합 작업을 수행할 기반 획득
  - 진행 상황에 대해 더 정확하게 감을 잡을 수 있음
- 예광탄 코드 vs 프로토타이핑
  - 프로토타입
    - 얻은 교훈으로 모두 버리고 새로 작성 가능
    - 최종 시스템에 특정 측면을 탐색하는 것이 목표
  - 예광탄 코드
    - 기능은 별로 없지만 완결된 코드
    - 앱의 전체적 연결 구조를 알고 싶어 함
    - 사용자에게 실제로 앱 요소들이 어떻게 상호작용하는지 알게 됨
    - 개발자에게 코드를 붙일 아키텍처 골격을 제시
  

  한 사이클을 한 기능에서 쭉 돌아보는 방식. 배포 환경에서 발견되는 문제점을 미리 발견할 수 있음. 가장 큰 위험 요소를 빨리 파악할수록 고치는데 필요한 비용은 줄어든다고 생각.


## Topic13 프로토타입과 포스트잇
프로토타입의 본질은 경험을 얻는 것. 제일 중요한 핵심 가치라고 생각
- 프로토타입을 꼭 코드로 짤 필요는 없다
  - 포스트잇 뿐만 아니라 Figma, Adobe XD, Framer, Sketch 등 다양한 도구가 있음 (Web 기준)
- 세부사항을 포기할 수 없는 경우 진짜 프로토타입이 맞는지 자문 → 예광탄이 더 적절할 수 있음
- Tip 21. 프로토타이핑으로 학습하라.
- 프로토타입을 코드로 만들 시 폐기처분 될 수 있다는 사실을 기억 및 상기
  - 프로젝트 후원자 및 관리자가 이를 보고 프로토타입을 보완해서 배포하자고 주장할 수 있음 ㅋㅋ

### 연습문제
15분만에 구현해서 연결하고 보여달라고? 15분만에 figma같은 도구에 숙련도가 있어서 뚝딱 만들면 하고 아니면 안하지 것보다 왜 나한테 시킴? 

## Topic14 도메인 언어
- Tip 22. 문제 도메인에 가깝게 프로그래밍하라.
  - 도메인 : 문제를 해결 하기 위한 영역
- 큐컴버는 행동 기반 테스트 코드이긴 하지만 결국 코드.. 그리고 사업부에서 안보겠지
  - 최대한 동작하는걸 보여줘야 함
  - 그리고 오이 별로임
- 도메인 언어의 특성
  - 내부 도메인: 랭귀지 종속적
  - 외부 도메인: 별도의 코드가 이 언어를 읽어들여서 사용
    - 결국 이것도 해당 규칙을 따라야 하는 것으로 보이는데..🧐
- yaml, json, csv 같은 통용되는 외부 언어 사용 권장

그냥 이렇게 도메인 언어를 구분 짓는구나하고 도메인 언어와 관련된 느낀점은 없음

## Topic15 추정
추정은 중요함. 실무에서도 추정되는 파일의 크기를 예측한다던지, 특정 시간 이벤트 트래픽을 예측하고 단위 시간 처리량이나 메모리를 계산해서 서버 인스턴스를 몇개 정도 띄울지.. 하는 것들이 그 예시가 됨

프로젝트 일정 추정에 대해서 이야기하면 일정 산정은 너무 어려워서 내가 모든 에너지를 쏟아부어서 가능한 일정 x 2.5 정도 한다.
이렇게 하면 단 기간에 할 수 있다고 얘기하고 못하는 것 보다, 엄청 오래 걸릴 줄 알았는데 생각보다 빨리 끝나면 좋아한다.

- 130일 걸린다와 6달쯤 걸린다의 차이는 확실히 생각해볼만한 지점
- 추정 실력을 기록하라
  - 이것도.. 복기해볼만한 가치가 있을 것 같다
- 일정을 실시간으로 조정해야 한다. 초기에 예상한 일정은 정확할수가 없음
- 누군가 추정해달라 하면? => 나중에 연락드릴게요 => 나중에 언제요? => ?
