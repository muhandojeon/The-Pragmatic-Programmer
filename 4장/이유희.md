##### Topic 23 계약에 의한 설계

소프트웨어 모듈의 권리와 책임을 문서화하고 검증하는 것이 계약에 의한 설계에 의한 핵심이다.
- 선행 조건

  루틴의 선행 조건이 위반된 경우에는 루틴이 호출되어서는 안 된다.
- 후행 조건

  루틴이 자기가 할 것이라고 보장하는 것. 무한 반복은 허용되지 않는다
- 클래스 불변식

  호출자의 입장에서 볼 때는 이 조건이 언제나 참인 것을 클래스가 보장한다
- 의미론적 불변식<br>
절대 어겨서는 안 되는 요구 사항을 표현할 수 있다. `결제를 중복으로 처리하면 안 된다` 등


lazy 코드를 작성해라. 시작하기 전에 수용할 것은 엄격하게 확인하고, 내어 줄 것에 대해서는 최소한도를 약속한다. 

코드를 작성하기 전에 유효한 입력 범위가 무엇인지, 경계 조건이 무엇인지, 루틴이 뭘 전달한다고 약속하는지, 혹은 더 중요하게는 무엇을 약속하지 않는지 등을 나열하는 것만으로도 더 나은 소프트웨어를 작성하는 데에 엄청난 도움이 된다. 
- 단정문
- DBC와 일찍 멈추기

> 객체로 전달되는 매개변수 유효성 검사를 매개변수 DTO, 생성자, 또는 메서드 중에서 어디서 할지 고민을 많이 했었는데<br>
> 계약에 의한 설계 개념을 알고 나니 이런 고민이 줄어들 것 같다.<br>
> 그리고 조건을 정의하고 합의하는 과정 자체가 객체를 모델링 하며 책임을 분명히 하는데 도움이 될 것 같다.<br>

> 실무를 경험해보니 계약 위배는 여러 레이어에서 다양한 이유로 발생한다.  
> 그냥 모든 레이어에서 선행 조건을 검증하는 것이 안전할 것 같고, 문서화와 테스트 케이스, 그리고 단정문으로 안전장치를 마련하고 팀원 모두가 함께 지키려고 노력해야 할 것 같다. 

##### Topic 24 죽은 프로그램은 거짓말을 하지 않는다

애플리케이션 코드가 오류 처리 코드 사이에 묻히지 않는다. 
```
try do 
  add_score_to_board(score);
 rescure Error1
    log_error();
    raise
 rescure Error2
    log_error();
    raise
end
```
> 나도 로깅을 위해 이런 형태로 코딩한 적이 있다. 다음엔 메서드 내부로 옮기자


망치지 말고 멈춰라 
- 방금 있을 수 없는 일이 발생했다는 것을 코드가 발견했다면 프로그램은 더는 유효하지 않다고 할 수 있다. 
> 개인적으로 실무에서 골치아픈 케이스는 망가진 코드를 탄 데이터가 그대로 데이터베이스에 반영되는 것이다. 나도 멈출 수 있으면 멈추고 싶다. 그런데 어떻게 멈추라는 거지..<br>


##### Topic 26 리소스 사용의 균형

- 자신이 시작한 것은 자신이 끝내라
- 중첩할당 (한 번에 여러 리소스를 사용하는 루틴)
  - 리소스를 할당한 순서의 역순으로 해제해라. 한 리소스가 다른 리소스를 참조하는 경우에도 참조를 망가트리지 않는다.
  - 동일한 구성의 리소스를 할당하는 경우에는 언제다 같은 순서로 할당해야 교착 가능성을 줄일 수 있다. 

> 자바를 사용하다 보니 리소스 할당과 해제를 직접 선언할 필요가 없어 생각하지 못했던 부분이다. 유익했다.


##### 해답18 Null 설정
> Java에서 개발자가 명시적으로 null을 할당한다고 해서 GC가 더 효율적으로 작동하지는 않는다고 한다.<br>
> 책에서 언급된 `실행 시간이 길어서 메모리 사용량이 시간이 지남에 따라 늘어나지 않도록 신경써야 하는 프로그램의 경우` 가 궁금해서 ChatGPT에게 물어봤다.<br>
> 그리고 재현해보려 했는데 잘 안 된다. 실무에서 메모리 할당 해제가 잘 안 될 때 다시 꺼내봐야겠다.



Java에서 개발자가 `null`을 할당하여 직접 참조 해제를 하는 것이 GC(Garbage Collector)에 도움이 될 수 있는 경우는 특정한 상황에서만 해당됩니다. 일반적으로 Java의 GC는 매우 효율적으로 동작하기 때문에, 명시적으로 `null`을 할당하여 참조를 해제해야 하는 경우는 드뭅니다. 그러나, 다음과 같은 경우에는 도움이 될 수 있습니다:

###### 1. **대형 객체의 조기 해제**:
- 만약 메모리를 많이 사용하는 대형 객체(예: 이미지, 대규모 배열 등)를 더 이상 사용하지 않게 된 경우, 해당 객체에 `null`을 할당하면 GC가 그 객체를 더 빨리 회수할 수 있습니다.
- 특히, 이런 객체가 긴 메서드 또는 루프 내에서 생성되고, 그 메서드나 루프가 완료되기 전까지 객체를 더 이상 사용하지 않게 되는 경우가 해당됩니다.
- 예시:
  ```java
  public void processLargeData() {
      LargeObject largeObject = new LargeObject();
      // 대형 객체를 사용하는 코드
      
      // 이제 largeObject가 더 이상 필요하지 않음
      largeObject = null; // 참조 해제
      
      // 이 후에 다른 작업 수행
  }
  ```
  > 아하 메서드 수행 시간이 길때 초반의 변수에 매우 큰 텍스트나 객체가 할당되고 쓰임이 다하면 null을 할당하면 
- 여기서 `largeObject`를 `null`로 설정함으로써, 이후의 코드에서 메모리 사용량을 줄이고 GC가 해당 객체를 더 빨리 수거할 수 있습니다.

###### 2. **긴 수명 주기의 객체에서 참조를 해제**:
- 클래스 필드에 저장된 객체 참조가 더 이상 필요하지 않을 때, 이를 `null`로 설정하여 참조를 해제하면 GC가 해당 객체를 수거할 수 있습니다.
- 예시:
  ```java
  public class Cache {
      private SomeObject cachedObject;
      
      public void clearCache() {
          cachedObject = null; // 참조 해제
      }
  }
  ```
- `cachedObject`가 메모리에 남아 있을 필요가 없다면 `null`을 할당하여 GC가 수거할 수 있도록 하는 것이 유리합니다.

###### 3. **대형 객체가 작은 스코프에서 생성될 때**:
- 특정 스코프 내에서 사용된 대형 객체가 스코프를 벗어나기 전에 계속 참조되는 경우, 명시적으로 `null`을 할당하여 해당 스코프가 끝나기 전에 참조를 해제하면 메모리 사용을 최적화할 수 있습니다.
- 예시:
  ```java
  public void process() {
      {
          LargeObject obj = new LargeObject();
          // obj를 사용한 작업 수행
          obj = null; // obj를 더 이상 사용하지 않음, 참조 해제
      }
      // 다른 작업 수행
  }
  ```

###### 4. **캐시와 같은 데이터 구조에서 참조 해제**:
- 캐시에서 사용되지 않는 객체를 직접 `null`로 할당하여 참조를 해제하면, GC가 해당 객체를 더 빨리 회수할 수 있습니다. 이는 메모리 사용량을 줄이고, OutOfMemoryError와 같은 문제를 예방할 수 있습니다.
- 예시:
  ```java
  public void removeFromCache(String key) {
      cacheMap.put(key, null); // 참조 해제
  }
  ```
