# 구부러지거나 부러지거나

현대의 미친 듯이 빠른 변화 속도에 맞추기 위해서는 가능한 느슨하고 유연한 코드를 작성하기 위해 노력해야 한다.

그렇지 않으면 코드는 금세 낡고 수정하기 어려워져 기억 저편으로 사라져 버릴 것이다.

## 결합도 줄이기와 디미터 법칙

* shy code
  + 자신을 남에게 속속들이 드러내지 말고, 너무 많은 사람과 상호작용하지 말라는 두 의미를 내포
  
* 코드를 세포(모듈)로 구성하고, 이들 간의 상호작용을 제한하라.
  + 그러면 한 모듈이 변경되거나 교체된다 하더라도 다른 모듈들은 변경 없이 수행될 수 있을 것이다.

> 적절히 제한하며, 변경이 일어났을 때 꼭 같이 변경이 되어야하는 곳은 빌드 타임에 알 수 있도록 하는 것도 중요하다고 생각 됨
> 혹은 같이 변경되거나.

* 의존 증가는 어딘가의 무관한 변화가 여러분의 코드에 영향을 미칠 수 있는 위험이 커지기 때문
  + 필요한 정보는 직접 물어보도록 한다
  + 불필요한 의존은 유지보수하기 어렵고, 시스템이 불안정한 경향을 띌 수 있음

```tsx
// option 1
const courseId = getCourseId();
const mentorList = useGetMentor(courseId);

// option 2
const useGetMentor = () => {
  const courseId = getCourseId();
}
const mentorList = useGetMentor();
```

> 일반적인 의존적 조회가 읽다가 생각났는데, 
> 여러분들은 어떤 것을 선호하시는지?
>
> 저는 전자의 방법을 선호하는데, 아래의 방법이 책에서 말하는 의존의 증가이지 않을까 싶어요

* 디미터 함수 법칙
  + 한 객체가 제공하는 메서드에 접근하기 위해 또 다른 객체들을 통하는 것을 허용하지 않음
  + 법칙을 지키다보면 성능이 단점으로 생길 수 있음
    - 해당 모듈들이 서로 결합하고 있다는 것을 잘 알고, 그것을 받아들일 수 있다면 아직 괜찮은 설계
    

```tsx
const analyticsDelegator = new AnalyticsDelegator();

analyticsDelegator.log('foo') // ok
analyticsDelegator.getPixel().log('foo') // bad
```

* 물리적 결합도
  + 논리적 설계와 물리적 설계가 함께 고려되어야 한다
  > 디렉터리 구조가 물리적 설계라 생각됨

## 메타 프로그래밍

* 세부사항은 우리의 깔끔한 코드를 어질러 놓는다

* 우리의 목표는 어떻게가 아닌 무엇을 해야 하는지를 명시함으로써 선언적으로 생각하는 것
  + 이로써 더 동적이고 적응가능한 프로그램을 만드는 것
  + **코드에는 추상화를, 메타데이터에는 세부 내용을**

* 설정 메타데이터를 일반 텍스트로 표현하는 것을 권장함. 그러면 삶이 훨씬 편해질 것임

* 도도 코드를 작성하지 말라
  + 환경에 적응하지 못한, 인류에 의한 첫 번째 멸종인 도도새에서 따옴
  + 메타데이터를 사용하지 않는다면 코드는 최대한의 적응성이나 유연성을 얻을 수 없다.

> 메타데이터 관련한 경험이 없는데, 여러분은 어떻게 세부 내용을 관리하시나요?

## 시간적 결합

* 시간에는 우리에게 의미 있는 두 가지 측면이 있다.
  + 동시성과 순서

* 작업흐름 분석을 통해 동시성을 개선해라
  + 작업흐름을 죽죽 기술해 놓고, 직접 보는 것은 놀라운 경험이 되기도 함

* 다중 쓰레드 프로그래밍은 몇 가지 설계상의 제약을 받게 되는데, 이것은 좋은 일
  + 워낙 도움이 많이 되어서 다른 어떤 프로그래밍을 하더라도 꼭 지키고 싶어지는 것이다.

* 모든 전역 변수나 정적 변수들을 동시 접근으로부터 보호해야 한다.
  + 왜 애초에 전역 변수가 필요했는지 스스로에게 물을 수 있는 좋은 기회

> 멀티 쓰레드 환경은 아니지만, 프로젝트 내의 복잡도가 올라가 디버깅이 힘들어진다는 이유로
> 전역 상태를 앵간해서는 잘 쓰고 있지 않아요
>
> 여러분은 어떠신가요??

* 동시성을 허용하도록 설계한다면, 확장가능성이나 성능에 대한 요구사항이 들어올 때 더 쉽게 그것에 맞출 수 있음
  + 그런 일이 들어오지 않아도 여전히 깔끔한 설계의 이점을 누림

## 단지 뷰일 뿐이야

* 우리는 객체가 서로에 대해 너무 많이 알기를 원하지 않는다
  + 우리는 모듈이 자기가 보고 싶은 것만 보도록 만들고 싶다

* 이벤트
  + 전송자는 수신자에 대해 아무런 직접적인 지식을 가질 필요가 없어 객체들 사이의 결합을 최소화할 수 있다
  + 출판과 구독 형태
    - P2P 기반
    - 소프트웨어 버스
      - 중앙 객체가 수신자들의 데이터베이스를 유지하면서 메시지들을 적절하게 전송
    

* MVC 패턴

> 저는 .. 대학생 때 RoR, Django를 주로 사용해왔어서 이에 익숙한데, 
> 모바일 진형에서는 MVVM이 거의 정답..처럼 쓰이는 느낌이더라구요
>  
> 둘 다 이해하기 편한 그림이 있는 아티클을 공유들비니다
> https://www.guru99.com/ko/mvc-vs-mvvm.html

## 칠판

* 형사가 사용하는 칠판
  + 어떤 프로젝트에서든 단순한 칠판 모델을 기반으로 해결 방안을 설계하기로 하면 작업할 때 쓸 수 있는 튼튼한 메타포가 생겼다.

* 칠판 시스템을 이용하면 지식 소비자와 생산자들이 익명으로 그리고 비동기적으로 데이터를 주고받는 공간이 생긴다
  + 그 덕분에 객체들 사이의 결합을 완전히 끊을 수 있다

> react-query의 cache가 칠판이지 않을까 생각이 들었음

* 칠판 정리하기
  + 사건의 규모가 큰 경우 칠판이 난잡해져 자료를 찾아보기 힘들어질 수 있음
  + 해결책은 여러 구획으로 나누고 어떤 방식으로든 자료를 정리하는 것

> react-query의 query key factory가 생각남
>
> 여러분은 어떻게 쿼리 키를 관리하시는지?
>
> v5에서 tkdodo씨가 예시를 든 쿼리키 팩토리: https://tkdodo.eu/blog/the-query-options-api
> v4에서 공식문서에 적힌 쿼리키 팩토리 라이브러리: https://github.com/lukemorales/query-key-factory

- 요구조건을 캡슐화하는 규칙 엔진과 칠판 시스템을 함께 사용하면 이러한 어려움들을 우아하게 해결할 수 있다
  > FLUX 패턴을 쓰는 그런 .. 도구들이 이런 느낌이지 않나 싶음
